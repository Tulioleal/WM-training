# ============================================================================
# CI/CD - Training Job (On-Demand)
# ============================================================================
#
# Disparar manualmente desde: Actions ‚Üí Training Job ‚Üí Run workflow
# Requiere que la imagen ya exista en Artifact Registry (ver build.yaml)
#
# ============================================================================

name: Training Job

on:
  workflow_dispatch:
    inputs:
      epochs:
        description: 'N√∫mero de epochs'
        default: '50'
        type: string
      batch_size:
        description: 'Batch size'
        default: '16'
        type: string
      patience:
        description: 'Early stopping patience'
        default: '10'
        type: string
      all_time:
        description: 'Usar TODAS las inferencias (ignorar √∫ltimo training)'
        default: false
        type: boolean

permissions:
  contents: read
  id-token: write

env:
  IMAGE_NAME: "training"
  WORKLOAD_IDENTITY_PROVIDER: "projects/${{ secrets.GCP_PROJECT_NUMBER }}/locations/global/workloadIdentityPools/github-actions-pool/providers/github-provider"

jobs:
  train:
    name: Run Training Job
    runs-on: ubuntu-latest
    environment: deploy

    steps:
      - name: Authenticate to GCP
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ env.WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ vars.SERVICE_ACCOUNT }}

      - name: Get GKE credentials
        uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: ${{ vars.GKE_CLUSTER }}
          location: ${{ vars.GCP_ZONE }}

      - name: Verify training image exists
        run: |
          gcloud artifacts docker images describe \
            ${{ vars.ARTIFACT_REGISTRY }}/${{ env.IMAGE_NAME }}:latest \
            --format="value(image_summary.digest)" || {
              echo "‚ùå La imagen de training no existe. Corr√© el workflow 'Build Training Image' primero."
              exit 1
            }

      - name: Build training args
        run: |
          ARGS="--from-inferences --only-verified --epochs=${{ inputs.epochs }} --batch-size=${{ inputs.batch_size }} --patience=${{ inputs.patience }}"
          if [ "${{ inputs.all_time }}" = "true" ]; then
            ARGS="$ARGS --all-time"
          fi
          echo "TRAINING_ARGS=$ARGS" >> $GITHUB_ENV
          echo "üìã Training args: $ARGS"

      - name: Launch training Job
        run: |
          # Construir args como lista YAML
          ARGS_YAML=""
          for arg in $TRAINING_ARGS; do
            ARGS_YAML="$ARGS_YAML
                    - \"$arg\""
          done

          cat <<EOF | kubectl create -f -
          apiVersion: batch/v1
          kind: Job
          metadata:
            generateName: training-job-
            namespace: waste-detection
          spec:
            backoffLimit: 2
            ttlSecondsAfterFinished: 86400
            template:
              spec:
                serviceAccountName: waste-detection-app-sa
                tolerations:
                  - key: workload
                    operator: Equal
                    value: training
                    effect: NoSchedule
                containers:
                  - name: training
                    image: ${{ vars.ARTIFACT_REGISTRY }}/${{ env.IMAGE_NAME }}:latest
                    args:${ARGS_YAML}
                    envFrom:
                      - configMapRef:
                          name: infra-config
                      - secretRef:
                          name: db-credentials
                    resources:
                      requests:
                        cpu: "2"
                        memory: "8Gi"
                        nvidia.com/gpu: "1"
                      limits:
                        cpu: "4"
                        memory: "12Gi"
                        nvidia.com/gpu: "1"
                restartPolicy: Never
          EOF

          # Capturar nombre del Job
          sleep 2
          JOB_NAME=$(kubectl get jobs -n waste-detection --sort-by=.metadata.creationTimestamp -o jsonpath='{.items[-1].metadata.name}')
          echo "JOB_NAME=$JOB_NAME" >> $GITHUB_ENV
          echo "‚úÖ Job lanzado: $JOB_NAME"

      - name: Wait for training to complete
        run: |
          echo "‚è≥ Esperando que el Job $JOB_NAME termine (timeout: 2h)..."
          kubectl wait --for=condition=complete job/$JOB_NAME \
            -n waste-detection \
            --timeout=7200s || {
              echo "‚ùå Training fall√≥ o excedi√≥ el timeout"
              kubectl logs job/$JOB_NAME -n waste-detection --tail=50
              exit 1
            }
          echo "‚úÖ Training completado exitosamente"

      - name: Show training logs
        if: always()
        run: |
          kubectl logs job/$JOB_NAME -n waste-detection --tail=100

      - name: Restart inference API
        if: success()
        run: |
          kubectl rollout restart deployment/inference-api -n waste-detection
          kubectl rollout status deployment/inference-api -n waste-detection --timeout=300s
          echo "‚úÖ API reiniciada con el nuevo modelo"